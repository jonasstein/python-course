\section{Object Oriented Programming}

\begin{frame}{Object Oriented Programming}
\begin{itemize}
\item So far: \alert{procedural programming}
\begin{itemize}
\item Data
\item Functions taking data as parameters and returning results
\end{itemize}
\item Alternative: Group data and functions belonging together to form \alert{custom data types}
\item $\rightarrow$ Extensions of structures in C/Fortran
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Using Simple Classes as Structs}
\begin{lstlisting}[style=Python]
class Point:
    pass

p = Point()
p.x = 2.0
p.y = 3.3
\end{lstlisting}
\begin{itemize}
\item \alert{Class}: Custom date type (here: \texttt{Point})
\item \alert{Object}: Instance of a class (here: \texttt{p})
\item Attributes (here \texttt{x}, \texttt{y}) can be added dynamically
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Classes}
\begin{lstlisting}[style=Python]
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(2.0, 3.0)
print p.x, p.y
p.x = 2.5
p.z = 42
\end{lstlisting}
\begin{itemize}
\item \texttt{\_\_init\_\_}: Is called automatically after creating an object
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Methods on Objects}
\begin{lstlisting}[style=Python]
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def norm(self):
        n = math.sqrt(self.x**2 + self.y**2)
        return n

p = Point(2.0, 3.0)
print p.x, p.y, p.norm()
\end{lstlisting}
\begin{itemize}
\item Method call: automatically sets the object as first parameter
\item $\rightarrow$ traditionally called \lstinline{self}
\item\alert{Careful}: Overloading of methods not possible!
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Converting Objects to Strings}
\onslide<1->
Default return value of \lstinline{str(...)} for objects of custom classes:
\begin{lstlisting}[style=Shell]
>>> p = Point(2.0, 3.0)
>>> print p  # --> print str(p)
<__main__.Point instance at 0x402d7a8c>
\end{lstlisting}
\vspace{2mm}

\onslide<2->
This behaviour can be overwritten:
\begin{lstlisting}[style=Python]
def __str__(self):
    return "(%i, %i)" % (self.x, self.y)
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> print p
(2, 3)
 \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Comparing Objects}
\onslide<1->
Default: \texttt{==} checks for object identity of custom objects.
\begin{lstlisting}[style=Shell]
>>> p1 = Point(2.0, 3.0)
>>> p2 = Point(2.0, 3.0)
>>> p1 == p2
False
\end{lstlisting}
%\vspace{2mm}
\onslide<2->
This behaviour can be overwritten:
\begin{lstlisting}[style=Python]
def __eq__(self, other):
    return (self.x == other.x) and
           (self.y == other.y)
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> p1 == p2 # Check for equal values
True
>>> p1 is p2 # Check for identity
False
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Comparing Objects}
More relational operators:
\begin{itemize}
\item \texttt{<} : \lstinline{__lt__(self, other)}
\item \texttt{<=} : \lstinline{__le__(self, other)}
\item \texttt{!=} : \lstinline{__ne__(self, other)}
\item \texttt{>} : \lstinline{__gt__(self, other)}
\item \texttt{>=} : \lstinline{__ge__(self, other)}
\end{itemize}
\vspace{2mm}
Alternative: \lstinline{__cmp__(self, other)}, returns:
\begin{itemize}
\item negative integer when \lstinline{self < other}
\item zero when \lstinline{self == other}
\item positive integer when \lstinline{self > other}
\end{itemize}
\end{frame}

\begin{frame}{Emulating Existing Data Types}
Classes can emulate built-in data types:
\begin{itemize}
\item Numbers: arithmetics, \texttt{int(myobj)}, \texttt{float(myobj)}, \dots
\item Functions: \texttt{myobj(...)}
\item Sequences: \texttt{len(myobj)}, \texttt{myobj[...]}, \lstinline{x in myobj}, ...
\item Iterators: \lstinline{for i in myobj}
\end{itemize}
\vspace{2mm}
See documentation:\\
\href{http://docs.python.org/ref/specialnames.html}{http://docs.python.org/ref/specialnames.html}
\end{frame}

\begin{frame}[fragile]{Class Variables}
Have the same value for all instances of a class:
\begin{lstlisting}[style=Python]
class Point:
    count = 0  # Count all point objects
    def __init__(self, x, y):
        self.__class__.count += 1
        ...
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> p1 = Point(2, 3); p2 = Point(3, 4)
>>> p1.count
2
>>> p2.count
2
>>> Point.count
2
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Class Methods and Static Methods}
\begin{lstlisting}[style=Python]
class Spam:
    spam = "I don't like spam."

    @classmethod
    def cmethod(cls):
        print cls.spam
       
    @staticmethod
    def smethod():
        print "Blah blah."
\end{lstlisting}
\begin{lstlisting}[style=Python]
Spam.cmethod()
Spam.smethod()
s = Spam()
s.cmethod()
s.smethod()
\end{lstlisting}
\end{frame}

\begin{frame}{Inheritance}
There are often classes that are very similar to each other.\\
\alert{Inheritance} allows for:
\begin{itemize}
\item Hierarchical class structure (is-a-relationship)
\item Reusing of similar code
\end{itemize}
\vspace{5mm}
Example: Different types of phones
\begin{itemize}
\item Phone
\item Mobile phone (is a phone with additional functionality)
\item Smart phone (is a mobile phone with additional functionality)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Inheritance}
\begin{lstlisting}[style=Python]
class Phone:
    def call(self):
        pass

class MobilePhone(Phone):
    def send_text(self):
        pass
\end{lstlisting}
MobilePhone now inherits methods and attributes from Phone.
\begin{lstlisting}[style=Python]
h = MobilePhone()
h.call() # inherited from Phone
h.send_text() # own method
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Overwriting Methods}
Methods of the parent class can be overwritten in the child class:
\begin{lstlisting}[style=Python]
class MobilePhone(Phone):
    def call(self):
        find_signal()
        Phone.call(self)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Multiple Inheritance}
Classes can inherit from multiple parent classes. Example:
\begin{itemize}
\item SmartPhone is a mobile phone
\item SmartPhone is a camera
\end{itemize}
\begin{lstlisting}[style=Python]
class SmartPhone(MobilePhone, Camera)
    pass

h = SmartPhone()
h.call()  # inherited from MobilePhone
h.take_photo() # inherited from Camera
\end{lstlisting}
Attributes are searched for in the following order:

SmartPhone, MobilePhone, parent class of MobilePhone (recursively), Camera, parent class of Camera (recursively).
\end{frame}

\begin{frame}[fragile]{Private Attributes}
\begin{itemize}
\item There are no private variables or private methods in Python.
\item \alert{Convention:} Mark attributes that shouldn't be accessed from outside with an underscore: \lstinline{_foo}.
\item To avoid name conflicts during inheritance: Names of the form \lstinline{__foo} are replaced with \lstinline{_classname__foo}:
\end{itemize}
\begin{lstlisting}[style=Python]
class Spam:
    __eggs = 3
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> dir(Spam)
>>> ['_Spam__eggs', '__doc__', '__module__']
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Properties}
If certain actions (checks, conversions) are to be executed while accessing attributes, use \alert{getter} and \alert{setter}:
\begin{lstlisting}[style=Python]
class Spam(object):
    def __init__(self):
        self._value = 0
    
    def get_value(self):
        return self._value

    def set_value(self, value):
        if value <= 0:  self._value = 0
        else:  self._value = value

    value = property(get_value, set_value)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Properties}
Properties can be accessed like any other attributes:
\begin{lstlisting}[style=Shell]
>>> s = Spam()
>>> s.value = 6   # set_value(6)
>>> s.value       # get_value()
>>> 6
>>> s.value = -6  # set_value(-6)
>>> s.value       # get_value()
>>> 0
\end{lstlisting}
\begin{itemize}
\item Getter and setter can be added later without changing the API
\item Access to \lstinline{_value} still possible
\end{itemize}

\end{frame}


