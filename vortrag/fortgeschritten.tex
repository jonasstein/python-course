\section{Neues in Python 2.5}

\begin{frame}[fragile]
\frametitle{Conditional Expressions}
Kurze Schreibweise f"ur bedingte Zuweisung. Statt:
\begin{lstlisting}
if zahl<0:
    s = "Negativ"
else:
    s = "Positiv"
\end{lstlisting}
kann man schreiben:
\begin{lstlisting}
s = "Negativ" if zahl<0 else "Positiv"
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Das \texttt{with}-Statement}
Einige Objekte bieten Kontext-Management an. Damit k"onnen \lstinline{try... finally}\,-Bl"ocke einfacher geschrieben werden:
\begin{lstlisting}
from __future__ import with_statement

with open("test.txt") as f:
    for line in f:
        print line
\end{lstlisting}
Nach dem \lstinline{with}-Block ist das Dateiobjekt stets wieder geschlossen, auch wenn im Block eine Exception auftrat.
\end{frame}

\begin{frame}[fragile]
\frametitle{Partielle Funktionsanwendung}
\begin{lstlisting}
import functools

def add (a, b):
    return a + b

add_ten = functools.partial(add, b=10)
add_ten(42)
\end{lstlisting}
\end{frame}

\section{Flexiblere Funktionen}

\begin{frame}[fragile]
\frametitle{Funktionsparameter aus Listen und Dictionaries}
\begin{lstlisting}
def spam(a, b, c, d):
    print a, b, c, d
\end{lstlisting}
Man kann positionale Parameter aus Listen erzeugen:
\begin{lstlisting}[style=Shell]
>>> args = [3, 6, 2, 3]
>>> spam(*args)
3 6 2 3
\end{lstlisting}
Man kann Keyword-Paramter aus Dictionaries erzeugen:
\begin{lstlisting}[style=Shell]
>>> kwargs = {"c": 5, "a": 2, "b": 4, "d":1}
>>> spam(**kwargs)
2 4 5 1
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Funktionen mit beliebigen Parametern}
\begin{lstlisting}
def spam(*args, **kwargs):
    for i in args:
        print i
    for i in kwargs:
        print i, kwargs[i]
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> spam(1, 2, c=3, d=4)
1
2
c 3
d 4
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Anonyme Funktionen}
\begin{lstlisting}
def make_incrementor(n):
    return lambda x: x + n
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
\end{lstlisting}
Sinnvoll, wenn einfache Funktionen als Parameter "ubergeben werden sollen.
\end{frame}

\section{Funktionale Techniken mit Listen}

\begin{frame}[fragile]
\frametitle{List Comprehension}
Abk"urzende Schreibweise zum Erstellen von Listen aus for-Schleifen. Statt:
\begin{lstlisting}
a = []
for i in range(10):
    a.append(i**2)
\end{lstlisting}
kann man schreiben:
\begin{lstlisting}
a = [i**2 for i in range(10)]
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Map}
Anwenden einer Funktion auf alle Elemente einer Liste:
\begin{lstlisting}[style=Shell]
>>> a = [1.6, 4.0, 81.0, 9.0]
>>> map(math.sqrt, a)
[1.2649110640673518, 2.0, 9.0, 3.0]
>>> map(lambda x: x * 2, a)
[3.2000000000000002, 8.0, 162.0, 18.0]
\end{lstlisting}
Wenn die Funktion mehr als einen Parameter nimmt, kann je zus"atzlichem Parameter eine weitere Liste "ubergeben werden:
\begin{lstlisting}[style=Shell]
>>> map(math.pow, a, [2 for i in a])
[2.5600000000000005, 16.0, 6561.0, 81.0]
\end{lstlisting}
\end{frame} 

\begin{frame}[fragile]
\frametitle{Filter}
Gibt Elemente einer Liste zur"uck, die nach Anwendung einer Funktion wahr sind:
\begin{lstlisting}[style=Shell]
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> filter(lambda x: x % 2, a)
[1, 3, 5, 7, 9]
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Reduce}
Wendet Funktion auf die ersten beiden Elemente an, dann auf das Ergebnis und das n"achste Element etc.
\begin{lstlisting}[style=Shell]
>>> def add(x, y):
...     return x + y
...
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> reduce(add, a)
45
\end{lstlisting}
Optionaler Startwert, der vor die Liste gesetzt wird:
\begin{lstlisting}[style=Shell]
>>> reduce(add, a, 10)
55
\end{lstlisting}
\end{frame}

\section{Iteratoren, Generatoren, Generator-Audr"ucke}

\begin{frame}[fragile]
\frametitle{Iteratoren}
Was passiert, wenn \lstinline{for} auf einem Objekt aufgerufen wird?
\begin{lstlisting}[style=Python]
for i in obj:
    pass
\end{lstlisting}
\begin{itemize}
\item Auf \lstinline{obj} wird die \lstinline{__iter__}-Methode aufgerufen, welche einen Iterator zur"uckgibt
\item Auf dem Iterator wird bei jedem Durchlauf \lstinline{next()} aufgerufen
\item Eine \lstinline{StopIteration}-Ausnahme beendet die for-Schleife
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Iteratoren}
\begin{lstlisting}[style=Python]
class Reverse:
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> for char in Reverse("spam"):
...     print char,
...
m a p s
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Generatoren}
Einfache Weise, Iteratoren zu erzeugen:
\begin{itemize}
\item Werden wie Funktionen definiert
\item \lstinline{yield}-Statement, um Daten zur"uckzugeben und beim n"achsten \lstinline{next}-Aufruf dort weiterzumachen
\end{itemize}
\begin{lstlisting}[style=Python]
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
\end{lstlisting}
\begin{lstlisting}[style=Shell]
>>> for char in reverse("spam"):
...     print char,
...
m a p s
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Generator-Audr"ucke}
"Ahnlich zu List Comprehensions kann man anonyme Iteratoren erzeugen:
\begin{lstlisting}[style=Shell]
>>> data = "spam"
>>> for c in (data[i] for i in
...           range(len(data)-1, -1, -1)):
...     print c,
...
m a p s
\end{lstlisting}
\end{frame}


\section{Etwas Dynamik}
\begin{frame}[fragile]
\frametitle{Dynamische Attribute}
Erinnerung: Man kann Attribute von Objekten zur Laufzeit hinzuf"ugen:
\begin{lstlisting}
class Empty:
    pass

a = Empty()
a.spam = 42
a.eggs = 17
\end{lstlisting}
\vspace{2mm}
Und entfernen:
\begin{lstlisting}
del a.spam
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{getattr, setattr}
Man kann Attribute von Objekten als Strings ansprechen:
\begin{lstlisting}
import math
f = getattr(math, "sin")
print f(x) # sin(x)
\end{lstlisting}
\vspace{2mm}
\begin{lstlisting}
a = Empty()
setattr(a, "spam", 42)
print a.spam
\end{lstlisting}
N"utzlich, wenn man z.B. Attributnamen aus User-Input oder Dateien liest.
\end{frame}

%%% Local Variables: 
%%% mode: latex
%%% latex-run-command: pdflatex
%%% TeX-master: "vortrag"
%%% End: 
